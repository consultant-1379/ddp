#!/usr/bin/env perl
######################################################################
#       Description ---------   parseOps -----------
#       This script parses the ops.xml file - OPS Instrumentation IP 23/15941-FCP 1038147 Rev B
#       It extracts the following.
#       Script Name, Script Time Started, Script Time Ended, Account whcih launched the script, CPU Usage.
#		The CPU Usage is: user + system CPU time in seconds with 2 decimals or NaN within a session. Reference 1/155 19-APR 901 0136 Uen OPS IWD
#
#       @author - Muhammad-Zeeshan Khan - emuhkha
#       usage  ${ANALYSIS_BIN}/server/parseOps ${OPS_LOG} ${SQL_DATE} ${SITE}
######################################################################

use strict;
use StatsDB;
use StatsCommon;
use DBI;
use Getopt::Long;
use XML::DOM;
use Data::Dumper;

our $debug;
our $arrCount=0;
our @opsRecs = ();
our %users = ();
our %scriptnames = ();

main();
sub main()
{
my $opslog;my $opsdir; my $sqldate; my $site; my $tableFile;
my $result = GetOptions(
        "file=s" => \$opslog,
        "dir=s" => \$opsdir,
        "date=s" => \$sqldate,
        "site=s" => \$site,
        "table=s" => \$tableFile,
        "debug=s" => \$debug
        );
    ($result == 1) or die "Invalid args";

    if ( defined $opslog )
    {
	    # If older version of DDC generated old ops.xml file then use this method 
        readOPSLog($opslog);
    }
    elsif ( defined $opsdir)
    {
	    # HL29568 : Else use the ops directory as the base to process the valid xml files.
        parseOPSXml($opsdir);
    }
	storeRecord($site,$sqldate);
}

####################################################################################
#	Function:			readOPSLog
# 	This function reads the ${OPS_LOG} passed as an argument. 
#	At every iteration it read the whole record i.e. <ops:record> to </ops:record>
#   and then passes that record chunck to processRecord method.
#   Argument:	None
#	Return:		None
####################################################################################
sub readOPSLog()
{
my ($log)=@_;
open READ_OPS, "<$log" or die "Can't open file $log\n";
$/="</ops:record>";
    while (<READ_OPS>)
    {
    processRecord($_);
    }
close READ_OPS;
}

####################################################################################
#	Function:			processRecord
#   This function processes the SINGLE ops.xml file generated by older version of DDC
# 	This function processes the record chunck read by readOPSLog method.
#	A record chunk is the data including & between <ops:record> to </ops:record>
#   It uses the regular expression to match and fetch the relevant values i.e. 
#	script_name, start time, stop time, cpu usage, & user.
#	The values are stored in an array to be used in storeRecord method.
#   
#   Argument:	An OPS Record: $_
#	Return:		None
####################################################################################
sub processRecord()
{
    my $opsRec = $_[0];
    my($start,$stop,$cpu,$user,$name)= $opsRec =~ /.*ops:start>(.*?)<\/ops:start>\n.*<ops:stop>(.*?)<\/ops:stop>\n.*<ops:cpuUsage>(.*?)<\/ops:cpuUsage>\n.*<ops:userAccount>(.*?)<\/ops:userAccount>\n.*\n.*\n.*\n.*<ops:scriptName>(.*?)<\/ops:scriptName>/mg;
    if ($debug eq "debug") { print "$start, $stop, $cpu, $user, $name\n"; }
	$name = jpsShortName($name);# To get the short name e.g. if it contains any known timestamps etc it will return a short name.
        if ($cpu =~ /^NaN/)
        {
          $cpu=0;
        }
	$opsRecs[$arrCount] = $name . "," . $start . "," . $stop . "," . $user . "," . $cpu;
	$users{$user} = $user;		# Storing unique user names - The final hashmap will be used to populate the oss_users table
	$scriptnames{$name} = $name;# Storing unique script names - The final hashmap will be used to populate the ops_scriptnames table
	$arrCount++;
	
}

####################################################################################
#       Function:                      parseOPSXml - HL29568
#       This function parses the "VALID" OPS XML files collected in ${DATADIR}/ops Directory.
#       
#   Argument:   dir
#   Return:         None
####################################################################################
sub parseOPSXml()
{
my ($dir) = @_;
my($start,$stop,$cpu,$user,$name);
opendir(DIR, $dir) or die "Invalid directory: " . $dir . "\n";
    my @allFiles = readdir(DIR);
closedir DIR;
    foreach my $file ( @allFiles ) {
        if ( $file =~ /^opsInstrumentation.*xml/ ) {
			if ($debug eq "debug") { print "Parsing $dir/$file\n"; }
		    my $parser = XML::DOM::Parser->new();
			my $data = $parser->parsefile($dir . "/" . $file) or die "Error parsing $dir/$file\n";
			my @opsRecords = $data->getElementsByTagName("ops:record");
			
			foreach my $opsRec (@opsRecords) 
			{
				my $ref=eval { $opsRec->getChildNodes(); };
				if ($@) 
				{
				 last;
				}
				my $nodes = $opsRec->getChildNodes();
				my $len = $nodes->getLength if ( $nodes);
				for (my $i = 0 ; $i < $len ; $i++) {
					my $n = $nodes->item($i);
					for ($n->getNodeName()) {
					    /^ops:start$/ and do { $start = $n->getFirstChild()->getData() ; last ; } ;
						/^ops:stop$/ and do { $stop = $n->getFirstChild()->getData() ; last ; } ;
						/^ops:cpuUsage$/ and do { $cpu = $n->getFirstChild()->getData() ; last ; } ;
						/^ops:userAccount$/ and do { $user = $n->getFirstChild()->getData() ; last ; } ;
						/^ops:scriptState$/ and do { $name=processScriptState($n) ; $name = jpsShortName($name); last ; };
					}
				}
				if ($cpu =~ /^NaN/)
				{
				  $cpu=0;
				}
				$opsRecs[$arrCount] = $name . "," . $start . "," . $stop . "," . $user . "," . $cpu;
				$users{$user} = $user;		# Storing unique user names - The final hashmap will be used to populate the oss_users table
				$scriptnames{$name} = $name;# Storing unique script names - The final hashmap will be used to populate the ops_scriptnames table
				$arrCount++;
			}
        }
    }
}
####################################################################################
#       Function:                      processScriptState - HL29568
#       This function parses the nested XML tag ops:scriptState. This nested scriptState
#       can be found within ops:record tag.
#       
#   Argument:   node
#   Return:         name - Name of script
####################################################################################
sub processScriptState()
{
my ($scriptState) = @_;
my $name="";    
my $nodes = $scriptState->getChildNodes();
    for (my $i = 0 ; $i < $nodes->getLength ; $i++) 
	{
    my $n = $nodes->item($i);
        for ($n->getNodeName()) 
		{
            /^ops:scriptName$/ and do { $name = $n->getFirstChild()->getData(); last; } ;
        }
    }
    return $name;
}

####################################################################################
#	Function:			storeRecord
# 	This function stores the record by reading the opsRecs array.
#	First it will record the new script names to ops_names DB Table, and then also stores 
#       the users in oss_users table. Then, it will iterate 
#	through each record i.e. script_name, start time, stop time, cpu usage, & user and insert it 
#	in ops table.
#   
#   Argument:	site, date
#	Return:		None
####################################################################################
sub storeRecord()
{
    my ($site,$date) = @_;
    my $dbh = connect_db();

    my $siteId = getSiteId($dbh,$site);
    ($siteId > -1 ) or die "Failed to get siteid for $site";

    my @scripts = keys %scriptnames;
    my $_nameIdMap = getIdMap($dbh, "ops_scriptnames", "id", "name", \@scripts );       # Inserting all scriptnames in ops_names table
    my @_usernames = keys %users;
    my $_userIdMap = getIdMap($dbh, "oss_users", "id", "name", \@_usernames );

    # If data is uploaded more than ONCE in a single day
    dbDo($dbh, "DELETE FROM ops_instrumentation WHERE start_time BETWEEN \"$date 00:00:00\" AND \"$date 23:59:59\" AND siteid=$siteId");
    if ($debug eq "debug" ) { print "DELETE FROM ops_instrumentation WHERE start_time BETWEEN \"$date 00:00:00\" AND \"$date 23:59:59\" AND siteid=$siteId\n"; }

    foreach my $value ( @opsRecs ) 
	{
    my $userId = 1;
    my($name,$start,$stop,$user,$cpu) = split(',',$value);
    $userId = $_userIdMap->{$user};
    my $opsId = $_nameIdMap->{$name};
    if ( $start !~ /\d+:\d+:\d+/ || $stop !~ /\d+:\d+:\d+/ )
    {
        if ($debug eq "debug" ) { print "Date Not Valid - start = $start stop = $stop\n"; }
        next;
    }
    # Because cpu field in the log file could be NaN that is why cpu is not defined float in DB table
    dbDo($dbh,"INSERT INTO ops_instrumentation (siteid, ops_script_id,userid,start_time,end_time,cpuusage) VALUES($siteId,$opsId,$userId,\"$start\",\"$stop\",$cpu)");
    if ($debug eq "debug" ) { print "INSERT INTO ops_instrumentation (siteid,ops_script_id,userid,start_time,end_time,ret_code) VALUES($siteId,$opsId,$userId,\"$start\",\"$stop\",$cpu)\n"; }
    }
    $dbh->disconnect;
}
