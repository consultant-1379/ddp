<?php
/*
   Used by SqlTable to generate the Javascript table

   Can also be used directly if you've got table data that can't be generated by an
   SQL query

   columns
   This is an array of column definiations
   key => id for the column
   label => Column header
   formatter => optional parameter, name of formatter function to be used
   sortOptions => optional parameter, defines the below two sorting behaviours:
       defaultDir -> optional parameter, ASC or DESC. Defines the very first sorting
                   direction when the user clicks the column header. Not supported
                   for dynamic data with server-side sorting
       sortFunction -> optional parameter, custom sorting function
   type => optional parameter, the data type of the column, if not set, string assumed

   options contains optional parameters
    order: array containing
     by: key of the column to initially sort on
     dir: ASC or DESC
    rowsPerPage: max rows to display on a page, if this is not present then all rows
       will be fetched with one query
    rowsPerPageOptions: other options for the rows per page, allows the user to change the
                        rows per page. The rowsPerPage is automatically added
    ctxMenu: This allows you create a pop menu for the table that will call page to the
             owning page with the selected rows
     url => URL to call when the menu is selected
     key => name of parameter added to the URL
     multi => allow multiple select or now (not implemented yet!)
     menu => array of menuitemId => menuItemLabel
     col => column key in table used to get the id of selected rows from
    e.g.
    'ctxMenu' => array('key' => 'threadpool',
      'multi' => true,
      'menu' => array( 'plot' => 'Plot' ),
      'url' => $_SERVER['PHP_SELF'] . "?" . $webargs,
      'col' => 'name' )

   When the user selected rows and then right clicks on Plot, the URL called with be
   url + "threadpool=plot&selected=<comma seperated list of names>

*/
require_once PHP_ROOT . "/common/functions.php";

class DDPTable {
  private $name;
  private $columns;
  private $options;
  private $dataSource;
  private static $loadJS = TRUE;

  const LABEL = 'label';
  const QUERY = 'query';
  const KEY = 'key';
  const DB = 'db';
  const TYPE = 'type';

  const FORMATTER = 'formatter';
  const FORMAT_NUM = 'ddpFormatNumber';
  const FORMAT_TIME = 'ddpFormatTime';
  const FORMAT_MSEC = 'ddpFormatMSec';
  const FORMAT_ROLLUP_TOTALS = 'ddpFormatRollupTotals';
  const FORMAT_ROLLUP_OTHER = 'ddpFormatRollupOther';

  const ORDER = 'order';
  const ROWS_PER_PAGE = 'rowsPerPage';
  const ROWS_PER_PAGE_OPTIONS = 'rowsPerPageOptions';
  const CTX_MENU = 'ctxMenu';
  const MULTI = 'multi';
  const MENU = 'menu';
  const URL = 'url';
  const COL = 'col';
  const ACTION = 'action';
  const VISIBLE = 'visible';
  const SORT_FUNCTION = 'sortFunction';
  const FORCE_SORT_NUMS = 'forceSortAsNums';
  const SORT_OPTS = 'sortOptions';

  const SORT_BY = 'by';
  const SORT_DIRECTION = 'dir';
  const SORT_ASC = 'ASC';
  const SORT_DESC = 'DESC';


 function __construct($name, $columns, $dataSource, $options = NULL) {
    global $debug;

    $this->name = $name;
    $this->columns = $columns;
    $this->options = $options;
    $this->dataSource = $dataSource;

    if ( $debug ) {
        echo "<pre>DDPTable $this->name dataSource\n"; var_dump($this->dataSource); echo "</pre>\n";
    }
  }

  function getTable( $excelDownloadId = '' ) {
    global $php_webroot, $debug;

    $tableTxt = array();

    $tableTxt[] = static::loadJavaScript();
    $tableTxt[] = "<div id=\"tablediv_" . $this->name . "\" class=\"yui-skin-sam\"></div>";
    $tableTxt[] = '<script type="text/javascript">';

    $colDefs = array();
    foreach ($this->columns as $column) {
      $colDef = array(
                      'key'   => $column['key'],
                      );
      if ( array_key_exists(self::LABEL, $column) ) {
        $colDef[self::LABEL] = $column[self::LABEL];
      }

      if ( array_key_exists(self::VISIBLE, $column) ) {
        $colDef[self::VISIBLE] = $column[self::VISIBLE];
      } else {
        $colDef[self::VISIBLE] = TRUE;
      }

      if ( array_key_exists(self::FORMATTER, $column) ) {
        $colDef[self::FORMATTER] = $column[self::FORMATTER];
      }

      if (  array_key_exists(self::SORT_OPTS, $column) ) {
        $colDef[self::SORT_OPTS] = $column[self::SORT_OPTS];
      }

      if ( array_key_exists(self::TYPE, $column) ) {
        $colDef[self::TYPE] = $column[self::TYPE];
      }

      # If no formatter given for numeric types then automatically add one
      if ( !array_key_exists(self::FORMATTER, $colDef) && array_key_exists(self::TYPE, $colDef)
           && ($colDef[self::TYPE] === 'int' || $colDef[self::TYPE] === 'real' || $colDef[self::TYPE] === 'float') ) {
          $colDef[self::FORMATTER] = 'ddpFormatNumber';
      }

      $colDefs[] = $colDef;
    }

    $tableParams =
      array(
            'name' => $this->name,
            'columns' => $colDefs,
            );

    if ( ! is_null($this->options) ) {
        # Order
        if ( array_key_exists(self::ORDER, $this->options) ) {
            $tableParams[self::ORDER] = $this->options[self::ORDER];
        }

        # Rows Per Page
        if ( array_key_exists(self::ROWS_PER_PAGE, $this->options) ) {
            # Only show the "Page" menu if we have more rows
            # then the rowsPerPage
            if ( array_key_exists('data', $this->dataSource ) ) {
                $rowCount = count($this->dataSource['data']);
            } else if ( array_key_exists( self::QUERY, $this->dataSource ) ) {
                $rowCount = $this->dataSource[self::QUERY]['totalRows'];
            }
            if ( $rowCount > $this->options[self::ROWS_PER_PAGE] ) {
                $useRowsPerPage = TRUE;
            } else {
                $useRowsPerPage = FALSE;
            }
            if ( $useRowsPerPage ) {
                $tableParams[self::ROWS_PER_PAGE] = $this->options[self::ROWS_PER_PAGE];
                if ( array_key_exists(self::ROWS_PER_PAGE_OPTIONS, $this->options) ) {
                    $tableParams[self::ROWS_PER_PAGE_OPTIONS] = array_merge(
                        array( $this->options[self::ROWS_PER_PAGE]),
                        $this->options[self::ROWS_PER_PAGE_OPTIONS]
                        );
                }
            }
        }

        # Context Menu
        if ( array_key_exists(self::CTX_MENU, $this->options) ) {
            $tableParams[self::CTX_MENU] = $this->options[self::CTX_MENU];
        }
    }

    $downloadURL = '';
    if ( array_key_exists('data', $this->dataSource ) ) {
      $tableParams['data'] = $this->dataSource['data'];
      $downloadURL = "$php_webroot/common/exportTable.php?" . $_SERVER['QUERY_STRING'];
    } else {
      $tableParams[self::QUERY] = $this->dataSource[self::QUERY];
      $downloadURL = $this->dataSource[self::QUERY]['url'] .  "?" . $_SERVER['QUERY_STRING'] . "&export=csv&qid=" . $this->dataSource[self::QUERY]['id'];
    }
    $tableParams['downloadURL'] = $downloadURL;

    if ( $debug > 1 ) { echo "<pre>tableParams\n"; print_r($tableParams); echo "</pre>\n"; }

    $tableParamsJSON = json_encode($tableParams, JSON_HEX_TAG|JSON_HEX_AMP|JSON_PRETTY_PRINT);
    if ( ! $tableParamsJSON ) {
      die("<pre>ERROR: Failed to encode table content " . json_last_error_msg() . "</pre>\n");
    }

    $tableTxt[] = "var " . $this->name . "_tableParam = " . $tableParamsJSON . ";";

    $tableTxt[] = "YAHOO.util.Event.addListener(window, \"load\", ddpShowTable, " .
      $this->name . "_tableParam);";
    if ( $excelDownloadId != '' ) {
      $tableTxt[] = "YAHOO.util.Event.addListener('$excelDownloadId', \"click\", downloadExcel, " . $this->name . "_tableParam);";
    }
    $tableTxt[] = "</script>";

    return implode("\n", $tableTxt) . "\n";
  }

  function getTableWithHeader($headerText, $headerLevel = 2, $helpTextOrID = '', $subText = '', $label = '') {
    if ($label == '') {
        $label = $this->name . "_header";
    }

    if ( $helpTextOrID == '' ) {
        $headerHTML = getHeader($headerText, $headerLevel, $this->name);
    } else {
        $headerHTML = drawHeaderWithHelp($headerText, $headerLevel, $label, $helpTextOrID, "ReturnContentAsString", '');
    }
    $tableHTML = $this->getTable();
    return $headerHTML . $subText . $tableHTML;
  }

  function getName() {
    return $this->name;
  }

  function getColumns() {
    return $this->columns;
  }

  function getDataSource() {
    return $this->dataSource;
  }

  public static function loadJavaScript() {
    global $php_webroot;

    if ( self::$loadJS ) {
      self::$loadJS = FALSE;
      return '<script type="text/javascript" src="' . $php_webroot . '/classes/ddptable.js"></script>';
    } else {
      return '';
    }
  }
}

?>
