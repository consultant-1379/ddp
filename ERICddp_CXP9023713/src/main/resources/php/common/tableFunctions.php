<?php
const ATT = 'Attribute';
const INST = 'Instance';

/**
 *Structures the data in a format that DDPTable can support.
 *
 *@author Patrick O Connor
 *
 *@param Array $rawData This is the raw data returned from getAggTableData which calls buildAggTableQuery
 *@param Array $aggregations In this case the aggregations are used to generate the column headings
 *@param Array $attributes These are the attributes that are to have the aggregation functions applied.
 */
function reStructureAggTableData( $rawData, $aggregations, $attributes ) {
    $structuredData = array();
    foreach ( $rawData as $row ) {
        $instance = $row['inst'];
        array_shift($row);
        foreach ( $attributes as $att ) {
            $data = array();
            $data[INST] = $instance;
            $data[ATT] = $att;
            foreach ( $aggregations as $agg) {
                $key = $agg . "_" . $att;
                $data[$agg] = (double)$row[$key];
            }
            $structuredData[] = $data;
        }
    }
    return $structuredData;
}

/**
 *Generates a query to get the aggregation data for the specified attributes.
 *
 *@author Patrick O Connor
 *
 *@param String $table This is the db table to be queried
 *@param Array $aggregations These are the SQL Functions to be applied to each attribute e.g. MIN,MAX,SUM,AVG
 *@param Array $attributes These are the attributes that are to have the aggregation functions applied.
 */
function buildAggTableQuery( $table, $aggregations, $attributes) {
    global $site, $date, $statsDB;

    $where = "WHERE ";
    $where .= $statsDB->where($table);
    $where .= " AND servers.id = $table.serverid GROUP BY serverid";

    $query = "SELECT servers.hostname AS inst";
    foreach ( $attributes as $att ) {
        foreach ( $aggregations as $agg ) {
            $as = $agg . "_" . $att;
            $query .= ", $agg($att) AS $as";
        }
    }
    $query .= " FROM $table, sites, servers ";
    return $query . $where;
}

/**
 *Runs the query generated by buildAggTableQuery.
 *
 *@author Patrick O Connor
 *
 *@param String $table This is the db table to be queried
 *@param Array $aggregations These are the SQL Functions to be applied to each attribute e.g. MIN,MAX,SUM,AVG
 *@param Array $attributes These are the attributes that are to have the aggregation functions applied.
 */
function getAggTableData( $table, $aggregations, $attributes ) {
    global $statsDB;

    $query = buildAggTableQuery( $table, $aggregations, $attributes );
    $statsDB->query( $query );
    while ( $row = $statsDB->getNextNamedRow() ) {
        $sqlData[] = $row;
    }

    if ( isset($sqlData) ) {
        return $sqlData;
    } else {
        return null;
    }
}

/**
 *Uses DDPTable to draw the table. The table can be clicked to plot graphs.
 *
 *@author Patrick O Connor
 *
 *@param Array $structuredData This contains the data to be displayed in the table.
 *@param Array $aggregations In this case the aggregations are used to generate the column headings.
 *@param String $table This is the table name.
 *@param String $sg This is the service group that the data to be presented belongs to.
 *@param String $instanceless This defaults to false. If set to true then we do not add an instance column.
 */
function drawAggTable( $structuredData, $aggregations, $table, $sg = '', $instanceless = false, $tableName = '' ) {

    if ( !$instanceless ) {
        array_unshift($aggregations, INST);
    }
    array_unshift($aggregations, ATT);

    $cols = array();

    foreach ( $aggregations as $col ) {
        $cols[] = array(
            'key' => $col,
            DDPTable::LABEL => $col,
            DDPTable::FORMATTER => DDPTable::FORMAT_NUM
        );
    }
    $url = makeSelfLink();
    if ($sg != '') {
        $url .= "&SG=$sg";
    }

    if ( $tableName != '' ) {
        $tabName = $tableName;
    } else {
        $tabName = $table;
    }

    $table = new DDPTable(
        "$tabName",
        $cols,
        array('data' => $structuredData),
        array(
            DDPTable::ROWS_PER_PAGE => 50,
            DDPTable::ROWS_PER_PAGE_OPTIONS => array(100, 1000),
            'ctxMenu' => array(
                            'key' => 'plot',
                            'menu' => array( 'true' => 'Plot' ),
                            'url' => $url,
                            'col' => ATT
            )
        )
    );

    echo $table->getTable();
}

/**
 *Generates the graphs from the rows selected on the DDPTable.
 *
 *@author Patrick O Connor
 *
 *@param Array $metrics The selected attributes from the rows selected on the DDPTable.
 *@param String $dbTable The db table to query.
 *@param String $width The width of the graph.
 *@param String $height The height of the graph.
 */
function buildGraphsFromSelectedMetrics( $metrics, $dbTable, $width=550, $height=320 ) {
    global $date, $site;

    $graphs = array();

    foreach ( $metrics as $col ) {
        $dbTables = array( $dbTable, StatsDB::SITES, StatsDB::SERVERS );

        $where = "$dbTable.siteid = sites.id
                  AND sites.name = '%s'
                  AND $dbTable.serverid = servers.id";

        $sqlParamWriter = new SqlPlotParam();

        $sqlParam = SqlPlotParamBuilder::init()
              ->title($col)
              ->type(SqlPlotParam::STACKED_BAR)
              ->barwidth(60)
              ->yLabel('Count')
              ->makePersistent()
              ->forceLegend()
              ->addQuery(
                  SqlPlotParam::DEFAULT_TIME_COL,
                  array ($col => $col),
                  $dbTables,
                  $where,
                  array('site'),
                  'servers.hostname'
              )
              ->build();

        $id = $sqlParamWriter->saveParams($sqlParam);
        $graphs[] = $sqlParamWriter->getImgURL($id, "$date 00:00:00", "$date 23:59:59", true, $width, $height);
    }
    return $graphs;
}

/**
 *Filters by instance then removes instance data. For use only when both instances have the same data e.g. kpiserv
 *
 *@author Patrick O Connor
 *
 *@param String $inst The instance to filter on.
 *@param Array $data The data that needs to be filtered.
 *@param Array $aggs The array of agregations.
 */
function filterSpecificInst( $inst, $data, $aggs ) {
    $filteredData = array();
    foreach ( $data as $arr ) {
        $parts = array();
        if ( $arr[INST] != $inst ) {
            $parts[ATT] = $arr[ATT];
            foreach ( $aggs as $ag ) {
                $parts[$ag] = $arr[$ag];
            }
            $filteredData[] = $parts;
        }
    }
    return $filteredData;
}

/**
 *Removes Attributes that have only 0 values(Probably should not be used with only MIN)
 *
 *@author Patrick O Connor
 *
 *@param Array $data The data that needs to be filtered.
 *@param Array $aggs The array of agregations.
 */
function removeEmptyGraphs( $data, $aggs ) {
    $validData = array();
    foreach ( $data as $arr ) {
        $valid = false;
        foreach ( $aggs as $ag ) {
            if ( $arr[$ag] != 0 ) {
                $valid = true;
            }
        }
        if ( $valid ) {
            $validData[] = $arr;
        }
    }
    return $validData;
}
